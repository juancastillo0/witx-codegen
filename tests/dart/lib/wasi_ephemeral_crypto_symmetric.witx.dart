
//
// This file was automatically generated by witx-codegen - Do not edit manually.
//

// ignore_for_file: non_constant_identifier_names

import 'dart:convert' show utf8;
import 'dart:ffi';
import 'dart:typed_data';

import 'package:ffi/ffi.dart' show malloc;

// #[derive(Debug, Copy, Clone, Eq, PartialEq)]
// pub enum Error {
//     WasiError(i32),
// }
// impl std::error::Error for Error {}
// impl std::fmt::Display for Error {
//     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
//         match self {
//             Error::WasiError(e) => write!(f, "Wasi error {}", e),
//         }
//     }
// }

class WasiError {
    final int code;
    const WasiError(this.code);

    @override
    String toString() {
        return 'WasiError{code: $code}';
    }
}

sealed class Result<O, E> {}

class Ok<O> implements Result<O, Never> {
    final O ok;
    const Ok(this.ok);
}

class Err<E> implements Result<Never, E> {
    final E err;
    const Err(this.err);
}

typedef i8 = Int8;
typedef i16 = Int16;
typedef i32 = Int32;
typedef i64 = Int64;
typedef u8 = Uint8;
typedef u16 = Uint16;
typedef u32 = Uint32;
typedef u64 = Uint64;
typedef usize = UintPtr;

typedef WasiHandle = i32;
typedef Char8 = u8;
typedef Char32 = u32;
typedef WasiPtr<T extends NativeType> = Pointer<T>;
typedef WasiMutPtr<T extends NativeType> = Pointer<T>;
typedef WasiStringBytesPtr = WasiPtr<Char8>;

// typedef WasiSlice<T extends NativeType> = Array<T>;

final class WasiSlice extends Struct {
    external WasiPtr<NativeType> ptr;
    @usize()
    external int len;

    List<T> asSlice<T>({
        required int itemSize,
        required T Function(WasiPtr<NativeType> ptr) fromPointer,
    }) {
        final result = <T>[];
        for (var i = ptr.address; i < len * itemSize; i += itemSize) {
            result.add(fromPointer(Pointer.fromAddress(i)));
        }
        return result;
    }

    static WasiSlice fromSlice<T>(
        List<T> slice, {
        required int itemSize,
        required void Function(T value, WasiPtr<NativeType> ptr) populatePointer,
    }) {
        final result = malloc<WasiSlice>();
        result.ref.ptr = malloc.allocate(slice.length * itemSize);
        result.ref.len = slice.length;
        final address = result.ref.ptr.address;
        for (var i = 0; i < slice.length; i++) {
            populatePointer(
                slice[i],
                Pointer.fromAddress(address + i * itemSize),
            );
        }
        return result.ref;
    }
}

final class WasiString extends Struct {
    external WasiStringBytesPtr ptr;
    @usize()
    external int len;

    static WasiString fromUtf8Slice(List<int> slice) {
        final stringPointer = malloc<WasiString>();
        final Pointer<Uint8> result = malloc<Uint8>(slice.length);
        result.asTypedList(slice.length).setAll(0, slice);

        return stringPointer.ref
            ..ptr = result
            ..len = slice.length;
    }

    static WasiString fromString(String v) {
        return fromUtf8Slice(utf8.encode(v));
    }

    Uint8List toUtf8Slice() {
        return ptr.asTypedList(len);
    }

    @override
    String toString() {
        final c = ptr.asTypedList(len);
        return utf8.decode(c);
    }
}

// ---------------------- Module: [wasi_ephemeral_crypto_symmetric] ----------------------

/// Error codes.
typedef CryptoErrno = int /* u16 */;

class CRYPTO_ERRNO {
    static const CryptoErrno SUCCESS = 0;
    static const CryptoErrno GUEST_ERROR = 1;
    static const CryptoErrno NOT_IMPLEMENTED = 2;
    static const CryptoErrno UNSUPPORTED_FEATURE = 3;
    static const CryptoErrno PROHIBITED_OPERATION = 4;
    static const CryptoErrno UNSUPPORTED_ENCODING = 5;
    static const CryptoErrno UNSUPPORTED_ALGORITHM = 6;
    static const CryptoErrno UNSUPPORTED_OPTION = 7;
    static const CryptoErrno INVALID_KEY = 8;
    static const CryptoErrno INVALID_LENGTH = 9;
    static const CryptoErrno VERIFICATION_FAILED = 10;
    static const CryptoErrno RNG_ERROR = 11;
    static const CryptoErrno ALGORITHM_FAILURE = 12;
    static const CryptoErrno INVALID_SIGNATURE = 13;
    static const CryptoErrno CLOSED = 14;
    static const CryptoErrno INVALID_HANDLE = 15;
    static const CryptoErrno OVERFLOW = 16;
    static const CryptoErrno INTERNAL_ERROR = 17;
    static const CryptoErrno TOO_MANY_HANDLES = 18;
    static const CryptoErrno KEY_NOT_SUPPORTED = 19;
    static const CryptoErrno KEY_REQUIRED = 20;
    static const CryptoErrno INVALID_TAG = 21;
    static const CryptoErrno INVALID_OPERATION = 22;
    static const CryptoErrno NONCE_REQUIRED = 23;
    static const CryptoErrno INVALID_NONCE = 24;
    static const CryptoErrno OPTION_NOT_SET = 25;
    static const CryptoErrno NOT_FOUND = 26;
    static const CryptoErrno PARAMETERS_MISSING = 27;
    static const CryptoErrno IN_PROGRESS = 28;
    static const CryptoErrno INCOMPATIBLE_KEYS = 29;
    static const CryptoErrno EXPIRED = 30;
}

/// Encoding to use for importing or exporting a key pair.
typedef KeypairEncoding = int /* u16 */;

class KEYPAIR_ENCODING {
    static const KeypairEncoding RAW = 0;
    static const KeypairEncoding PKCS_8 = 1;
    static const KeypairEncoding PEM = 2;
    static const KeypairEncoding LOCAL = 3;
}

/// Encoding to use for importing or exporting a public key.
typedef PublickeyEncoding = int /* u16 */;

class PUBLICKEY_ENCODING {
    static const PublickeyEncoding RAW = 0;
    static const PublickeyEncoding PKCS_8 = 1;
    static const PublickeyEncoding PEM = 2;
    static const PublickeyEncoding SEC = 3;
    static const PublickeyEncoding COMPRESSED_SEC = 4;
    static const PublickeyEncoding LOCAL = 5;
}

/// Encoding to use for importing or exporting a secret key.
typedef SecretkeyEncoding = int /* u16 */;

class SECRETKEY_ENCODING {
    static const SecretkeyEncoding RAW = 0;
    static const SecretkeyEncoding PKCS_8 = 1;
    static const SecretkeyEncoding PEM = 2;
    static const SecretkeyEncoding SEC = 3;
    static const SecretkeyEncoding COMPRESSED_SEC = 4;
    static const SecretkeyEncoding LOCAL = 5;
}

/// Encoding to use for importing or exporting a signature.
typedef SignatureEncoding = int /* u16 */;

class SIGNATURE_ENCODING {
    static const SignatureEncoding RAW = 0;
    static const SignatureEncoding DER = 1;
}

/// An algorithm category.
typedef AlgorithmType = int /* u16 */;

class ALGORITHM_TYPE {
    static const AlgorithmType SIGNATURES = 0;
    static const AlgorithmType SYMMETRIC = 1;
    static const AlgorithmType KEY_EXCHANGE = 2;
}

/// Version of a managed key.
/// 
/// A version can be an arbitrary `u64` integer, with the expection of some reserved values.
typedef Version = int /* u64 */;

/// Size of a value.
typedef Size = int /* usize */;

/// A UNIX timestamp, in seconds since 01/01/1970.
typedef Timestamp = int /* u64 */;

/// A 64-bit value
typedef U64 = int /* u64 */;

/// Handle for functions returning output whose size may be large or not known in advance.
/// 
/// An `array_output` object contains a host-allocated byte array.
/// 
/// A guest can get the size of that array after a function returns in order to then allocate a buffer of the correct size.
/// In addition, the content of such an object can be consumed by a guest in a streaming fashion.
/// 
/// An `array_output` handle is automatically closed after its full content has been consumed.
typedef ArrayOutput = WasiHandle;

/// A set of options.
/// 
/// This type is used to set non-default parameters.
/// 
/// The exact set of allowed options depends on the algorithm being used.
typedef Options = WasiHandle;

/// A handle to the optional secrets management facilities offered by a host.
/// 
/// This is used to generate, retrieve and invalidate managed keys.
typedef SecretsManager = WasiHandle;

/// A key pair.
typedef Keypair = WasiHandle;

/// A state to absorb data to be signed.
/// 
/// After a signature has been computed or verified, the state remains valid for further operations.
/// 
/// A subsequent signature would sign all the data accumulated since the creation of the state object.
typedef SignatureState = WasiHandle;

/// A signature.
typedef Signature = WasiHandle;

/// A public key, for key exchange and signature verification.
typedef Publickey = WasiHandle;

/// A secret key, for key exchange mechanisms.
typedef Secretkey = WasiHandle;

/// A state to absorb signed data to be verified.
typedef SignatureVerificationState = WasiHandle;

/// A state to perform symmetric operations.
/// 
/// The state is not reset nor invalidated after an option has been performed.
/// Incremental updates and sessions are thus supported.
typedef SymmetricState = WasiHandle;

/// A symmetric key.
/// 
/// The key can be imported from raw bytes, or can be a reference to a managed key.
/// 
/// If it was imported, the host will wipe it from memory as soon as the handle is closed.
typedef SymmetricKey = WasiHandle;

/// An authentication tag.
/// 
/// This is an object returned by functions computing authentication tags.
/// 
/// A tag can be compared against another tag (directly supplied as raw bytes) in constant time with the `symmetric_tag_verify()` function.
/// 
/// This object type can't be directly created from raw bytes. They are only returned by functions computing MACs.
/// 
/// The host is reponsible for securely wiping them from memory on close.
typedef SymmetricTag = WasiHandle;

/// Options index, only required by the Interface Types translation layer.
typedef OptOptionsU = int /* u8 */;

class OPT_OPTIONS_U {
    static const OptOptionsU SOME = 0;
    static const OptOptionsU NONE = 1;
}

/// An optional options set.
/// 
/// This union simulates an `Option<Options>` type to make the `options` parameter of some functions optional.
final class OptOptionsMember extends Union {
    @WasiHandle() external Options some; // if tag=0
    // none with no associated value if tag=1
}

final class OptOptions extends Struct {
    @u8() external int /* u8 */ tag;
    @u8() external int __pad8_0;
    @u16() external int __pad16_0;
    @u32() external int __pad32_0;
    external Pointer<OptOptionsMember> member;
    static OptOptions fromTag(int /* u8 */ tag) {
        final tu = malloc<OptOptions>();
        tu.ref.tag = tag;
        return tu.ref;
    }


    // --- some: Options if tag=0

    OptOptions newSome(Options val) {
        final tu = fromTag(0);
        tu.member.ref.some = val;
        return tu;
    }

    Options intoSome() {
        assert(tag == 0);
        return member.ref.some;
    }

    void setSome(Options val) {
        assert(tag == 0);
        member.ref.some = val;
    }

    bool isSome() {
        return tag == 0;
    }


    // --- none: (no associated content) if tag=1

    OptOptions newNone() {
        return fromTag(1);
    }

    bool isNone() {
        return tag == 1;
    }

}


/// Symmetric key index, only required by the Interface Types translation layer.
typedef OptSymmetricKeyU = int /* u8 */;

class OPT_SYMMETRIC_KEY_U {
    static const OptSymmetricKeyU SOME = 0;
    static const OptSymmetricKeyU NONE = 1;
}

/// An optional symmetric key.
/// 
/// This union simulates an `Option<SymmetricKey>` type to make the `symmetric_key` parameter of some functions optional.
final class OptSymmetricKeyMember extends Union {
    @WasiHandle() external SymmetricKey some; // if tag=0
    // none with no associated value if tag=1
}

final class OptSymmetricKey extends Struct {
    @u8() external int /* u8 */ tag;
    @u8() external int __pad8_0;
    @u16() external int __pad16_0;
    @u32() external int __pad32_0;
    external Pointer<OptSymmetricKeyMember> member;
    static OptSymmetricKey fromTag(int /* u8 */ tag) {
        final tu = malloc<OptSymmetricKey>();
        tu.ref.tag = tag;
        return tu.ref;
    }


    // --- some: SymmetricKey if tag=0

    OptSymmetricKey newSome(SymmetricKey val) {
        final tu = fromTag(0);
        tu.member.ref.some = val;
        return tu;
    }

    SymmetricKey intoSome() {
        assert(tag == 0);
        return member.ref.some;
    }

    void setSome(SymmetricKey val) {
        assert(tag == 0);
        member.ref.some = val;
    }

    bool isSome() {
        return tag == 0;
    }


    // --- none: (no associated content) if tag=1

    OptSymmetricKey newNone() {
        return fromTag(1);
    }

    bool isNone() {
        return tag == 1;
    }

}


/// Generate a new symmetric key for a given algorithm.
/// 
/// `options` can be `None` to use the default parameters, or an algoritm-specific set of parameters to override.
/// 
/// This function may return `unsupported_feature` if key generation is not supported by the host for the chosen algorithm, or `unsupported_algorithm` if the algorithm is not supported by the host.
Result<SymmetricKey, Error> symmetricKeyGenerate(
    WasiPtr<u8> algorithmPtr,
    int /* usize */ algorithmLen,
    OptOptions options,
) {
    final symmetricKeyGenerate = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            int /* Char8 */ algorithmPtr,
            usize algorithmLen,
            unimplemented!() options,
            SymmetricKey resultPtr,
        ),            CryptoErrno Function(

                WasiPtr<u8> algorithmPtr,
                int /* usize */ algorithmLen,
                OptOptions options,
                WasiPtr<WasiHandle> /* Mut */ resultPtr,
            )>('symmetric_key_generate');    final resultPtr = malloc<WasiHandle>();
    final res = symmetricKeyGenerate(
        algorithmPtr,
        algorithmLen,
        options,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// Create a symmetric key from raw material.
/// 
/// The algorithm is internally stored along with the key, and trying to use the key with an operation expecting a different algorithm will return `invalid_key`.
/// 
/// The function may also return `unsupported_algorithm` if the algorithm is not supported by the host.
Result<SymmetricKey, Error> symmetricKeyImport(
    WasiPtr<u8> algorithmPtr,
    int /* usize */ algorithmLen,
    WasiPtr<u8> raw,
    Size rawLen,
) {
    final symmetricKeyImport = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            int /* Char8 */ algorithmPtr,
            usize algorithmLen,
            int /* u8 */ raw,
            usize rawLen,
            SymmetricKey resultPtr,
        ),            CryptoErrno Function(

                WasiPtr<u8> algorithmPtr,
                int /* usize */ algorithmLen,
                WasiPtr<u8> raw,
                Size rawLen,
                WasiPtr<WasiHandle> /* Mut */ resultPtr,
            )>('symmetric_key_import');    final resultPtr = malloc<WasiHandle>();
    final res = symmetricKeyImport(
        algorithmPtr,
        algorithmLen,
        raw,
        rawLen,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// Export a symmetric key as raw material.
/// 
/// This is mainly useful to export a managed key.
/// 
/// May return `prohibited_operation` if this operation is denied.
Result<ArrayOutput, Error> symmetricKeyExport(
    SymmetricKey symmetricKey,
) {
    final symmetricKeyExport = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle symmetricKey,
            ArrayOutput resultPtr,
        ),            CryptoErrno Function(

                SymmetricKey symmetricKey,
                WasiPtr<WasiHandle> /* Mut */ resultPtr,
            )>('symmetric_key_export');    final resultPtr = malloc<WasiHandle>();
    final res = symmetricKeyExport(
        symmetricKey,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// Destroy a symmetric key.
/// 
/// Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
Result<(), Error> symmetricKeyClose(
    SymmetricKey symmetricKey,
) {
    final symmetricKeyClose = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle symmetricKey,
        ),            CryptoErrno Function(

                SymmetricKey symmetricKey,
            )>('symmetric_key_close');    final res = symmetricKeyClose(
        symmetricKey,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(());
}

/// __(optional)__
/// Generate a new managed symmetric key.
/// 
/// The key is generated and stored by the secrets management facilities.
/// 
/// It may be used through its identifier, but the host may not allow it to be exported.
/// 
/// The function returns the `unsupported_feature` error code if secrets management facilities are not supported by the host,
/// or `unsupported_algorithm` if a key cannot be created for the chosen algorithm.
/// 
/// The function may also return `unsupported_algorithm` if the algorithm is not supported by the host.
/// 
/// This is also an optional import, meaning that the function may not even exist.
Result<SymmetricKey, Error> symmetricKeyGenerateManaged(
    SecretsManager secretsManager,
    WasiPtr<u8> algorithmPtr,
    int /* usize */ algorithmLen,
    OptOptions options,
) {
    final symmetricKeyGenerateManaged = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle secretsManager,
            int /* Char8 */ algorithmPtr,
            usize algorithmLen,
            unimplemented!() options,
            SymmetricKey resultPtr,
        ),            CryptoErrno Function(

                SecretsManager secretsManager,
                WasiPtr<u8> algorithmPtr,
                int /* usize */ algorithmLen,
                OptOptions options,
                WasiPtr<WasiHandle> /* Mut */ resultPtr,
            )>('symmetric_key_generate_managed');    final resultPtr = malloc<WasiHandle>();
    final res = symmetricKeyGenerateManaged(
        secretsManager,
        algorithmPtr,
        algorithmLen,
        options,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// __(optional)__
/// Store a symmetric key into the secrets manager.
/// 
/// On success, the function stores the key identifier into `$symmetric_key_id`,
/// into which up to `$symmetric_key_id_max_len` can be written.
/// 
/// The function returns `overflow` if the supplied buffer is too small.
Result<(), Error> symmetricKeyStoreManaged(
    SecretsManager secretsManager,
    SymmetricKey symmetricKey,
    WasiPtr<u8> /* Mut */ symmetricKeyId,
    Size symmetricKeyIdMaxLen,
) {
    final symmetricKeyStoreManaged = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle secretsManager,
            WasiHandle symmetricKey,
            int /* u8 */ symmetricKeyId,
            usize symmetricKeyIdMaxLen,
        ),            CryptoErrno Function(

                SecretsManager secretsManager,
                SymmetricKey symmetricKey,
                WasiPtr<u8> /* Mut */ symmetricKeyId,
                Size symmetricKeyIdMaxLen,
            )>('symmetric_key_store_managed');    final res = symmetricKeyStoreManaged(
        secretsManager,
        symmetricKey,
        symmetricKeyId,
        symmetricKeyIdMaxLen,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(());
}

/// __(optional)__
/// Replace a managed symmetric key.
/// 
/// This function crates a new version of a managed symmetric key, by replacing `$kp_old` with `$kp_new`.
/// 
/// It does several things:
/// 
/// - The key identifier for `$symmetric_key_new` is set to the one of `$symmetric_key_old`.
/// - A new, unique version identifier is assigned to `$kp_new`. This version will be equivalent to using `$version_latest` until the key is replaced.
/// - The `$symmetric_key_old` handle is closed.
/// 
/// Both keys must share the same algorithm and have compatible parameters. If this is not the case, `incompatible_keys` is returned.
/// 
/// The function may also return the `unsupported_feature` error code if secrets management facilities are not supported by the host,
/// or if keys cannot be rotated.
/// 
/// Finally, `prohibited_operation` can be returned if `$symmetric_key_new` wasn't created by the secrets manager, and the secrets manager prohibits imported keys.
/// 
/// If the operation succeeded, the new version is returned.
/// 
/// This is an optional import, meaning that the function may not even exist.
Result<Version, Error> symmetricKeyReplaceManaged(
    SecretsManager secretsManager,
    SymmetricKey symmetricKeyOld,
    SymmetricKey symmetricKeyNew,
) {
    final symmetricKeyReplaceManaged = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle secretsManager,
            WasiHandle symmetricKeyOld,
            WasiHandle symmetricKeyNew,
            Version resultPtr,
        ),            CryptoErrno Function(

                SecretsManager secretsManager,
                SymmetricKey symmetricKeyOld,
                SymmetricKey symmetricKeyNew,
                WasiPtr<u64> /* Mut */ resultPtr,
            )>('symmetric_key_replace_managed');    final resultPtr = malloc<u64>();
    final res = symmetricKeyReplaceManaged(
        secretsManager,
        symmetricKeyOld,
        symmetricKeyNew,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// __(optional)__
/// Return the key identifier and version of a managed symmetric key.
/// 
/// If the key is not managed, `unsupported_feature` is returned instead.
/// 
/// This is an optional import, meaning that the function may not even exist.
Result<(Size, Version), Error> symmetricKeyId(
    SymmetricKey symmetricKey,
    WasiPtr<u8> /* Mut */ symmetricKeyId,
    Size symmetricKeyIdMaxLen,
) {
    final symmetricKeyId = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle symmetricKey,
            int /* u8 */ symmetricKeyId,
            usize symmetricKeyIdMaxLen,
            Size result0Ptr,
            Version result1Ptr,
        ),            CryptoErrno Function(

                SymmetricKey symmetricKey,
                WasiPtr<u8> /* Mut */ symmetricKeyId,
                Size symmetricKeyIdMaxLen,
                WasiPtr<usize> /* Mut */ result0Ptr,
                WasiPtr<u64> /* Mut */ result1Ptr,
            )>('symmetric_key_id');    final result0Ptr = malloc<usize>();
    final result1Ptr = malloc<u64>();
    final res = symmetricKeyId(
        symmetricKey,
        symmetricKeyId,
        symmetricKeyIdMaxLen,
        result0Ptr,
        result1Ptr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok((result0Ptr.ref, result1Ptr.ref));
}

/// __(optional)__
/// Return a managed symmetric key from a key identifier.
/// 
/// `kp_version` can be set to `version_latest` to retrieve the most recent version of a symmetric key.
/// 
/// If no key matching the provided information is found, `not_found` is returned instead.
/// 
/// This is an optional import, meaning that the function may not even exist.
Result<SymmetricKey, Error> symmetricKeyFromId(
    SecretsManager secretsManager,
    WasiPtr<u8> symmetricKeyId,
    Size symmetricKeyIdLen,
    Version symmetricKeyVersion,
) {
    final symmetricKeyFromId = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle secretsManager,
            int /* u8 */ symmetricKeyId,
            usize symmetricKeyIdLen,
            u64 symmetricKeyVersion,
            SymmetricKey resultPtr,
        ),            CryptoErrno Function(

                SecretsManager secretsManager,
                WasiPtr<u8> symmetricKeyId,
                Size symmetricKeyIdLen,
                Version symmetricKeyVersion,
                WasiPtr<WasiHandle> /* Mut */ resultPtr,
            )>('symmetric_key_from_id');    final resultPtr = malloc<WasiHandle>();
    final res = symmetricKeyFromId(
        secretsManager,
        symmetricKeyId,
        symmetricKeyIdLen,
        symmetricKeyVersion,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// Create a new state to aborb and produce data using symmetric operations.
/// 
/// The state remains valid after every operation in order to support incremental updates.
/// 
/// The function has two optional parameters: a key and an options set.
/// 
/// It will fail with a `key_not_supported` error code if a key was provided but the chosen algorithm doesn't natively support keying.
/// 
/// On the other hand, if a key is required, but was not provided, a `key_required` error will be thrown.
/// 
/// Some algorithms may require additional parameters. They have to be supplied as an options set:
/// 
/// ```rust
/// let options_handle = ctx.options_open()?;
/// ctx.options_set("context", b"My application")?;
/// ctx.options_set_u64("fanout", 16)?;
/// let state_handle = ctx.symmetric_state_open("BLAKE2b-512", None, Some(options_handle))?;
/// ```
/// 
/// If some parameters are mandatory but were not set, the `parameters_missing` error code will be returned.
/// 
/// A notable exception is the `nonce` parameter, that is common to most AEAD constructions.
/// 
/// If a nonce is required but was not supplied:
/// 
/// - If it is safe to do so, the host will automatically generate a nonce. This is true for nonces that are large enough to be randomly generated, or if the host is able to maintain a global counter.
/// - If not, the function will fail and return the dedicated `nonce_required` error code.
/// 
/// A nonce that was automatically generated can be retrieved after the function returns with `symmetric_state_get(state_handle, "nonce")`.
/// 
/// **Sample usage patterns:**
/// 
/// - **Hashing**
/// 
/// ```rust
/// let mut out = [0u8; 64];
/// let state_handle = ctx.symmetric_state_open("SHAKE-128", None, None)?;
/// ctx.symmetric_state_absorb(state_handle, b"data")?;
/// ctx.symmetric_state_absorb(state_handle, b"more_data")?;
/// ctx.symmetric_state_squeeze(state_handle, &mut out)?;
/// ```
/// 
/// - **MAC**
/// 
/// ```rust
/// let mut raw_tag = [0u8; 64];
/// let key_handle = ctx.symmetric_key_import("HMAC/SHA-512", b"key")?;
/// let state_handle = ctx.symmetric_state_open("HMAC/SHA-512", Some(key_handle), None)?;
/// ctx.symmetric_state_absorb(state_handle, b"data")?;
/// ctx.symmetric_state_absorb(state_handle, b"more_data")?;
/// let computed_tag_handle = ctx.symmetric_state_squeeze_tag(state_handle)?;
/// ctx.symmetric_tag_pull(computed_tag_handle, &mut raw_tag)?;
/// ```
/// 
/// Verification:
/// 
/// ```rust
/// let state_handle = ctx.symmetric_state_open("HMAC/SHA-512", Some(key_handle), None)?;
/// ctx.symmetric_state_absorb(state_handle, b"data")?;
/// ctx.symmetric_state_absorb(state_handle, b"more_data")?;
/// let computed_tag_handle = ctx.symmetric_state_squeeze_tag(state_handle)?;
/// ctx.symmetric_tag_verify(computed_tag_handle, expected_raw_tag)?;
/// ```
/// 
/// - **Tuple hashing**
/// 
/// ```rust
/// let mut out = [0u8; 64];
/// let state_handle = ctx.symmetric_state_open("TupleHashXOF256", None, None)?;
/// ctx.symmetric_state_absorb(state_handle, b"value 1")?;
/// ctx.symmetric_state_absorb(state_handle, b"value 2")?;
/// ctx.symmetric_state_absorb(state_handle, b"value 3")?;
/// ctx.symmetric_state_squeeze(state_handle, &mut out)?;
/// ```
/// Unlike MACs and regular hash functions, inputs are domain separated instead of being concatenated.
/// 
/// - **Key derivation using extract-and-expand**
/// 
/// Extract:
/// 
/// ```rust
/// let mut prk = vec![0u8; 64];
/// let key_handle = ctx.symmetric_key_import("HKDF-EXTRACT/SHA-512", b"key")?;
/// let state_handle = ctx.symmetric_state_open("HKDF-EXTRACT/SHA-512", Some(key_handle), None)?;
/// ctx.symmetric_state_absorb(state_handle, b"salt")?;
/// let prk_handle = ctx.symmetric_state_squeeze_key(state_handle, "HKDF-EXPAND/SHA-512")?;
/// ```
/// 
/// Expand:
/// 
/// ```rust
/// let mut subkey = vec![0u8; 32];
/// let state_handle = ctx.symmetric_state_open("HKDF-EXPAND/SHA-512", Some(prk_handle), None)?;
/// ctx.symmetric_state_absorb(state_handle, b"info")?;
/// ctx.symmetric_state_squeeze(state_handle, &mut subkey)?;
/// ```
/// 
/// - **Key derivation using a XOF**
/// 
/// ```rust
/// let mut subkey1 = vec![0u8; 32];
/// let mut subkey2 = vec![0u8; 32];
/// let key_handle = ctx.symmetric_key_import("BLAKE3", b"key")?;
/// let state_handle = ctx.symmetric_state_open("BLAKE3", Some(key_handle), None)?;
/// ctx.symmetric_absorb(state_handle, b"context")?;
/// ctx.squeeze(state_handle, &mut subkey1)?;
/// ctx.squeeze(state_handle, &mut subkey2)?;
/// ```
/// 
/// - **Password hashing**
/// 
/// ```rust
/// let mut memory = vec![0u8; 1_000_000_000];
/// let options_handle = ctx.symmetric_options_open()?;
/// ctx.symmetric_options_set_guest_buffer(options_handle, "memory", &mut memory)?;
/// ctx.symmetric_options_set_u64(options_handle, "opslimit", 5)?;
/// ctx.symmetric_options_set_u64(options_handle, "parallelism", 8)?;
/// 
/// let state_handle = ctx.symmetric_state_open("ARGON2-ID-13", None, Some(options))?;
/// ctx.symmtric_state_absorb(state_handle, b"password")?;
/// 
/// let pw_str_handle = ctx.symmetric_state_squeeze_tag(state_handle)?;
/// let mut pw_str = vec![0u8; ctx.symmetric_tag_len(pw_str_handle)?];
/// ctx.symmetric_tag_pull(pw_str_handle, &mut pw_str)?;
/// ```
/// 
/// - **AEAD encryption with an explicit nonce**
/// 
/// ```rust
/// let key_handle = ctx.symmetric_key_generate("AES-256-GCM", None)?;
/// let message = b"test";
/// 
/// let options_handle = ctx.symmetric_options_open()?;
/// ctx.symmetric_options_set(options_handle, "nonce", nonce)?;
/// 
/// let state_handle = ctx.symmetric_state_open("AES-256-GCM", Some(key_handle), Some(options_handle))?;
/// let mut ciphertext = vec![0u8; message.len() + ctx.symmetric_state_max_tag_len(state_handle)?];
/// ctx.symmetric_state_absorb(state_handle, "additional data")?;
/// ctx.symmetric_state_encrypt(state_handle, &mut ciphertext, message)?;
/// ```
/// 
/// - **AEAD encryption with automatic nonce generation**
/// 
/// ```rust
/// let key_handle = ctx.symmetric_key_generate("AES-256-GCM-SIV", None)?;
/// let message = b"test";
/// let mut nonce = [0u8; 24];
/// 
/// let state_handle = ctx.symmetric_state_open("AES-256-GCM-SIV", Some(key_handle), None)?;
/// 
/// let nonce_handle = ctx.symmetric_state_options_get(state_handle, "nonce")?;
/// ctx.array_output_pull(nonce_handle, &mut nonce)?;
/// 
/// let mut ciphertext = vec![0u8; message.len() + ctx.symmetric_state_max_tag_len(state_handle)?];
/// ctx.symmetric_state_absorb(state_handle, "additional data")?;
/// ctx.symmetric_state_encrypt(state_handle, &mut ciphertext, message)?;
/// ```
/// 
/// - **Session authenticated modes**
/// 
/// ```rust
/// let mut out = [0u8; 16];
/// let mut out2 = [0u8; 16];
/// let mut ciphertext = [0u8; 20];
/// let key_handle = ctx.symmetric_key_generate("Xoodyak-128", None)?;
/// let state_handle = ctx.symmetric_state_open("Xoodyak-128", Some(key_handle), None)?;
/// ctx.symmetric_state_absorb(state_handle, b"data")?;
/// ctx.symmetric_state_encrypt(state_handle, &mut ciphertext, b"abcd")?;
/// ctx.symmetric_state_absorb(state_handle, b"more data")?;
/// ctx.symmetric_state_squeeze(state_handle, &mut out)?;
/// ctx.symmetric_state_squeeze(state_handle, &mut out2)?;
/// ctx.symmetric_state_ratchet(state_handle)?;
/// ctx.symmetric_state_absorb(state_handle, b"more data")?;
/// let next_key_handle = ctx.symmetric_state_squeeze_key(state_handle, "Xoodyak-128")?;
/// // ...
/// ```
Result<SymmetricState, Error> symmetricStateOpen(
    WasiPtr<u8> algorithmPtr,
    int /* usize */ algorithmLen,
    OptSymmetricKey key,
    OptOptions options,
) {
    final symmetricStateOpen = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            int /* Char8 */ algorithmPtr,
            usize algorithmLen,
            unimplemented!() key,
            unimplemented!() options,
            SymmetricState resultPtr,
        ),            CryptoErrno Function(

                WasiPtr<u8> algorithmPtr,
                int /* usize */ algorithmLen,
                OptSymmetricKey key,
                OptOptions options,
                WasiPtr<WasiHandle> /* Mut */ resultPtr,
            )>('symmetric_state_open');    final resultPtr = malloc<WasiHandle>();
    final res = symmetricStateOpen(
        algorithmPtr,
        algorithmLen,
        key,
        options,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// Retrieve a parameter from the current state.
/// 
/// In particular, `symmetric_state_options_get("nonce")` can be used to get a nonce that as automatically generated.
/// 
/// The function may return `options_not_set` if an option was not set, which is different from an empty value.
/// 
/// It may also return `unsupported_option` if the option doesn't exist for the chosen algorithm.
Result<Size, Error> symmetricStateOptionsGet(
    SymmetricState handle,
    WasiPtr<u8> namePtr,
    int /* usize */ nameLen,
    WasiPtr<u8> /* Mut */ value,
    Size valueMaxLen,
) {
    final symmetricStateOptionsGet = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle handle,
            int /* Char8 */ namePtr,
            usize nameLen,
            int /* u8 */ value,
            usize valueMaxLen,
            Size resultPtr,
        ),            CryptoErrno Function(

                SymmetricState handle,
                WasiPtr<u8> namePtr,
                int /* usize */ nameLen,
                WasiPtr<u8> /* Mut */ value,
                Size valueMaxLen,
                WasiPtr<usize> /* Mut */ resultPtr,
            )>('symmetric_state_options_get');    final resultPtr = malloc<usize>();
    final res = symmetricStateOptionsGet(
        handle,
        namePtr,
        nameLen,
        value,
        valueMaxLen,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// Retrieve an integer parameter from the current state.
/// 
/// In particular, `symmetric_state_options_get("nonce")` can be used to get a nonce that as automatically generated.
/// 
/// The function may return `options_not_set` if an option was not set.
/// 
/// It may also return `unsupported_option` if the option doesn't exist for the chosen algorithm.
Result<U64, Error> symmetricStateOptionsGetU64(
    SymmetricState handle,
    WasiPtr<u8> namePtr,
    int /* usize */ nameLen,
) {
    final symmetricStateOptionsGetU64 = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle handle,
            int /* Char8 */ namePtr,
            usize nameLen,
            U64 resultPtr,
        ),            CryptoErrno Function(

                SymmetricState handle,
                WasiPtr<u8> namePtr,
                int /* usize */ nameLen,
                WasiPtr<u64> /* Mut */ resultPtr,
            )>('symmetric_state_options_get_u64');    final resultPtr = malloc<u64>();
    final res = symmetricStateOptionsGetU64(
        handle,
        namePtr,
        nameLen,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// Destroy a symmetric state.
/// 
/// Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
Result<(), Error> symmetricStateClose(
    SymmetricState handle,
) {
    final symmetricStateClose = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle handle,
        ),            CryptoErrno Function(

                SymmetricState handle,
            )>('symmetric_state_close');    final res = symmetricStateClose(
        handle,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(());
}

/// Absorb data into the state.
/// 
/// - **Hash functions:** adds data to be hashed.
/// - **MAC functions:** adds data to be authenticated.
/// - **Tuplehash-like constructions:** adds a new tuple to the state.
/// - **Key derivation functions:** adds to the IKM or to the subkey information.
/// - **AEAD constructions:** adds additional data to be authenticated.
/// - **Stateful hash objects, permutation-based constructions:** absorbs.
/// 
/// If the chosen algorithm doesn't accept input data, the `invalid_operation` error code is returned.
/// 
/// If too much data has been fed for the algorithm, `overflow` may be thrown.
Result<(), Error> symmetricStateAbsorb(
    SymmetricState handle,
    WasiPtr<u8> data,
    Size dataLen,
) {
    final symmetricStateAbsorb = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle handle,
            int /* u8 */ data,
            usize dataLen,
        ),            CryptoErrno Function(

                SymmetricState handle,
                WasiPtr<u8> data,
                Size dataLen,
            )>('symmetric_state_absorb');    final res = symmetricStateAbsorb(
        handle,
        data,
        dataLen,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(());
}

/// Squeeze bytes from the state.
/// 
/// - **Hash functions:** this tries to output an `out_len` bytes digest from the absorbed data. The hash function output will be truncated if necessary. If the requested size is too large, the `invalid_len` error code is returned.
/// - **Key derivation functions:** : outputs an arbitrary-long derived key.
/// - **RNGs, DRBGs, stream ciphers:**: outputs arbitrary-long data.
/// - **Stateful hash objects, permutation-based constructions:** squeeze.
/// 
/// Other kinds of algorithms may return `invalid_operation` instead.
/// 
/// For password-stretching functions, the function may return `in_progress`.
/// In that case, the guest should retry with the same parameters until the function completes.
Result<(), Error> symmetricStateSqueeze(
    SymmetricState handle,
    WasiPtr<u8> /* Mut */ out,
    Size outLen,
) {
    final symmetricStateSqueeze = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle handle,
            int /* u8 */ out,
            usize outLen,
        ),            CryptoErrno Function(

                SymmetricState handle,
                WasiPtr<u8> /* Mut */ out,
                Size outLen,
            )>('symmetric_state_squeeze');    final res = symmetricStateSqueeze(
        handle,
        out,
        outLen,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(());
}

/// Compute and return a tag for all the data injected into the state so far.
/// 
/// - **MAC functions**: returns a tag authenticating the absorbed data.
/// - **Tuplehash-like constructions:** returns a tag authenticating all the absorbed tuples.
/// - **Password-hashing functions:** returns a standard string containing all the required parameters for password verification.
/// 
/// Other kinds of algorithms may return `invalid_operation` instead.
/// 
/// For password-stretching functions, the function may return `in_progress`.
/// In that case, the guest should retry with the same parameters until the function completes.
Result<SymmetricTag, Error> symmetricStateSqueezeTag(
    SymmetricState handle,
) {
    final symmetricStateSqueezeTag = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle handle,
            SymmetricTag resultPtr,
        ),            CryptoErrno Function(

                SymmetricState handle,
                WasiPtr<WasiHandle> /* Mut */ resultPtr,
            )>('symmetric_state_squeeze_tag');    final resultPtr = malloc<WasiHandle>();
    final res = symmetricStateSqueezeTag(
        handle,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// Use the current state to produce a key for a target algorithm.
/// 
/// For extract-then-expand constructions, this returns the PRK.
/// For session-base authentication encryption, this returns a key that can be used to resume a session without storing a nonce.
/// 
/// `invalid_operation` is returned for algorithms not supporting this operation.
Result<SymmetricKey, Error> symmetricStateSqueezeKey(
    SymmetricState handle,
    WasiPtr<u8> algStrPtr,
    int /* usize */ algStrLen,
) {
    final symmetricStateSqueezeKey = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle handle,
            int /* Char8 */ algStrPtr,
            usize algStrLen,
            SymmetricKey resultPtr,
        ),            CryptoErrno Function(

                SymmetricState handle,
                WasiPtr<u8> algStrPtr,
                int /* usize */ algStrLen,
                WasiPtr<WasiHandle> /* Mut */ resultPtr,
            )>('symmetric_state_squeeze_key');    final resultPtr = malloc<WasiHandle>();
    final res = symmetricStateSqueezeKey(
        handle,
        algStrPtr,
        algStrLen,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// Return the maximum length of an authentication tag for the current algorithm.
/// 
/// This allows guests to compute the size required to store a ciphertext along with its authentication tag.
/// 
/// The returned length may include the encryption mode's padding requirements in addition to the actual tag.
/// 
/// For an encryption operation, the size of the output buffer should be `input_len + symmetric_state_max_tag_len()`.
/// 
/// For a decryption operation, the size of the buffer that will store the decrypted data must be `ciphertext_len - symmetric_state_max_tag_len()`.
Result<Size, Error> symmetricStateMaxTagLen(
    SymmetricState handle,
) {
    final symmetricStateMaxTagLen = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle handle,
            Size resultPtr,
        ),            CryptoErrno Function(

                SymmetricState handle,
                WasiPtr<usize> /* Mut */ resultPtr,
            )>('symmetric_state_max_tag_len');    final resultPtr = malloc<usize>();
    final res = symmetricStateMaxTagLen(
        handle,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// Encrypt data with an attached tag.
/// 
/// - **Stream cipher:** adds the input to the stream cipher output. `out_len` and `data_len` can be equal, as no authentication tags will be added.
/// - **AEAD:** encrypts `data` into `out`, including the authentication tag to the output. Additional data must have been previously absorbed using `symmetric_state_absorb()`. The `symmetric_state_max_tag_len()` function can be used to retrieve the overhead of adding the tag, as well as padding if necessary.
/// - **SHOE, Xoodyak, Strobe:** encrypts data, squeezes a tag and appends it to the output.
/// 
/// If `out` and `data` are the same address, encryption may happen in-place.
/// 
/// The function returns the actual size of the ciphertext along with the tag.
/// 
/// `invalid_operation` is returned for algorithms not supporting encryption.
Result<Size, Error> symmetricStateEncrypt(
    SymmetricState handle,
    WasiPtr<u8> /* Mut */ out,
    Size outLen,
    WasiPtr<u8> data,
    Size dataLen,
) {
    final symmetricStateEncrypt = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle handle,
            int /* u8 */ out,
            usize outLen,
            int /* u8 */ data,
            usize dataLen,
            Size resultPtr,
        ),            CryptoErrno Function(

                SymmetricState handle,
                WasiPtr<u8> /* Mut */ out,
                Size outLen,
                WasiPtr<u8> data,
                Size dataLen,
                WasiPtr<usize> /* Mut */ resultPtr,
            )>('symmetric_state_encrypt');    final resultPtr = malloc<usize>();
    final res = symmetricStateEncrypt(
        handle,
        out,
        outLen,
        data,
        dataLen,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// Encrypt data, with a detached tag.
/// 
/// - **Stream cipher:** returns `invalid_operation` since stream ciphers do not include authentication tags.
/// - **AEAD:** encrypts `data` into `out` and returns the tag separately. Additional data must have been previously absorbed using `symmetric_state_absorb()`. The output and input buffers must be of the same length.
/// - **SHOE, Xoodyak, Strobe:** encrypts data and squeezes a tag.
/// 
/// If `out` and `data` are the same address, encryption may happen in-place.
/// 
/// The function returns the tag.
/// 
/// `invalid_operation` is returned for algorithms not supporting encryption.
Result<SymmetricTag, Error> symmetricStateEncryptDetached(
    SymmetricState handle,
    WasiPtr<u8> /* Mut */ out,
    Size outLen,
    WasiPtr<u8> data,
    Size dataLen,
) {
    final symmetricStateEncryptDetached = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle handle,
            int /* u8 */ out,
            usize outLen,
            int /* u8 */ data,
            usize dataLen,
            SymmetricTag resultPtr,
        ),            CryptoErrno Function(

                SymmetricState handle,
                WasiPtr<u8> /* Mut */ out,
                Size outLen,
                WasiPtr<u8> data,
                Size dataLen,
                WasiPtr<WasiHandle> /* Mut */ resultPtr,
            )>('symmetric_state_encrypt_detached');    final resultPtr = malloc<WasiHandle>();
    final res = symmetricStateEncryptDetached(
        handle,
        out,
        outLen,
        data,
        dataLen,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// - **Stream cipher:** adds the input to the stream cipher output. `out_len` and `data_len` can be equal, as no authentication tags will be added.
/// - **AEAD:** decrypts `data` into `out`. Additional data must have been previously absorbed using `symmetric_state_absorb()`.
/// - **SHOE, Xoodyak, Strobe:** decrypts data, squeezes a tag and verify that it matches the one that was appended to the ciphertext.
/// 
/// If `out` and `data` are the same address, decryption may happen in-place.
/// 
/// `out_len` must be exactly `data_len` + `max_tag_len` bytes.
/// 
/// The function returns the actual size of the decrypted message, which can be smaller than `out_len` for modes that requires padding.
/// 
/// `invalid_tag` is returned if the tag didn't verify.
/// 
/// `invalid_operation` is returned for algorithms not supporting encryption.
Result<Size, Error> symmetricStateDecrypt(
    SymmetricState handle,
    WasiPtr<u8> /* Mut */ out,
    Size outLen,
    WasiPtr<u8> data,
    Size dataLen,
) {
    final symmetricStateDecrypt = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle handle,
            int /* u8 */ out,
            usize outLen,
            int /* u8 */ data,
            usize dataLen,
            Size resultPtr,
        ),            CryptoErrno Function(

                SymmetricState handle,
                WasiPtr<u8> /* Mut */ out,
                Size outLen,
                WasiPtr<u8> data,
                Size dataLen,
                WasiPtr<usize> /* Mut */ resultPtr,
            )>('symmetric_state_decrypt');    final resultPtr = malloc<usize>();
    final res = symmetricStateDecrypt(
        handle,
        out,
        outLen,
        data,
        dataLen,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// - **Stream cipher:** returns `invalid_operation` since stream ciphers do not include authentication tags.
/// - **AEAD:** decrypts `data` into `out`. Additional data must have been previously absorbed using `symmetric_state_absorb()`.
/// - **SHOE, Xoodyak, Strobe:** decrypts data, squeezes a tag and verify that it matches the expected one.
/// 
/// `raw_tag` is the expected tag, as raw bytes.
/// 
/// `out` and `data` be must have the same length.
/// If they also share the same address, decryption may happen in-place.
/// 
/// The function returns the actual size of the decrypted message.
/// 
/// `invalid_tag` is returned if the tag verification failed.
/// 
/// `invalid_operation` is returned for algorithms not supporting encryption.
Result<Size, Error> symmetricStateDecryptDetached(
    SymmetricState handle,
    WasiPtr<u8> /* Mut */ out,
    Size outLen,
    WasiPtr<u8> data,
    Size dataLen,
    WasiPtr<u8> rawTag,
    Size rawTagLen,
) {
    final symmetricStateDecryptDetached = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle handle,
            int /* u8 */ out,
            usize outLen,
            int /* u8 */ data,
            usize dataLen,
            int /* u8 */ rawTag,
            usize rawTagLen,
            Size resultPtr,
        ),            CryptoErrno Function(

                SymmetricState handle,
                WasiPtr<u8> /* Mut */ out,
                Size outLen,
                WasiPtr<u8> data,
                Size dataLen,
                WasiPtr<u8> rawTag,
                Size rawTagLen,
                WasiPtr<usize> /* Mut */ resultPtr,
            )>('symmetric_state_decrypt_detached');    final resultPtr = malloc<usize>();
    final res = symmetricStateDecryptDetached(
        handle,
        out,
        outLen,
        data,
        dataLen,
        rawTag,
        rawTagLen,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// Make it impossible to recover the previous state.
/// 
/// This operation is supported by some systems keeping a rolling state over an entire session, for forward security.
/// 
/// `invalid_operation` is returned for algorithms not supporting ratcheting.
Result<(), Error> symmetricStateRatchet(
    SymmetricState handle,
) {
    final symmetricStateRatchet = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle handle,
        ),            CryptoErrno Function(

                SymmetricState handle,
            )>('symmetric_state_ratchet');    final res = symmetricStateRatchet(
        handle,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(());
}

/// Return the length of an authentication tag.
/// 
/// This function can be used by a guest to allocate the correct buffer size to copy a computed authentication tag.
Result<Size, Error> symmetricTagLen(
    SymmetricTag symmetricTag,
) {
    final symmetricTagLen = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle symmetricTag,
            Size resultPtr,
        ),            CryptoErrno Function(

                SymmetricTag symmetricTag,
                WasiPtr<usize> /* Mut */ resultPtr,
            )>('symmetric_tag_len');    final resultPtr = malloc<usize>();
    final res = symmetricTagLen(
        symmetricTag,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// Copy an authentication tag into a guest-allocated buffer.
/// 
/// The handle automatically becomes invalid after this operation. Manually closing it is not required.
/// 
/// Example usage:
/// 
/// ```rust
/// let mut raw_tag = [0u8; 16];
/// ctx.symmetric_tag_pull(raw_tag_handle, &mut raw_tag)?;
/// ```
/// 
/// The function returns `overflow` if the supplied buffer is too small to copy the tag.
/// 
/// Otherwise, it returns the number of bytes that have been copied.
Result<Size, Error> symmetricTagPull(
    SymmetricTag symmetricTag,
    WasiPtr<u8> /* Mut */ buf,
    Size bufLen,
) {
    final symmetricTagPull = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle symmetricTag,
            int /* u8 */ buf,
            usize bufLen,
            Size resultPtr,
        ),            CryptoErrno Function(

                SymmetricTag symmetricTag,
                WasiPtr<u8> /* Mut */ buf,
                Size bufLen,
                WasiPtr<usize> /* Mut */ resultPtr,
            )>('symmetric_tag_pull');    final resultPtr = malloc<usize>();
    final res = symmetricTagPull(
        symmetricTag,
        buf,
        bufLen,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// Verify that a computed authentication tag matches the expected value, in constant-time.
/// 
/// The expected tag must be provided as a raw byte string.
/// 
/// The function returns `invalid_tag` if the tags don't match.
/// 
/// Example usage:
/// 
/// ```rust
/// let key_handle = ctx.symmetric_key_import("HMAC/SHA-256", b"key")?;
/// let state_handle = ctx.symmetric_state_open("HMAC/SHA-256", Some(key_handle), None)?;
/// ctx.symmetric_state_absorb(state_handle, b"data")?;
/// let computed_tag_handle = ctx.symmetric_state_squeeze_tag(state_handle)?;
/// ctx.symmetric_tag_verify(computed_tag_handle, expected_raw_tag)?;
/// ```
Result<(), Error> symmetricTagVerify(
    SymmetricTag symmetricTag,
    WasiPtr<u8> expectedRawTagPtr,
    Size expectedRawTagLen,
) {
    final symmetricTagVerify = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle symmetricTag,
            int /* u8 */ expectedRawTagPtr,
            usize expectedRawTagLen,
        ),            CryptoErrno Function(

                SymmetricTag symmetricTag,
                WasiPtr<u8> expectedRawTagPtr,
                Size expectedRawTagLen,
            )>('symmetric_tag_verify');    final res = symmetricTagVerify(
        symmetricTag,
        expectedRawTagPtr,
        expectedRawTagLen,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(());
}

/// Explicitly destroy an unused authentication tag.
/// 
/// This is usually not necessary, as `symmetric_tag_pull()` automatically closes a tag after it has been copied.
/// 
/// Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
Result<(), Error> symmetricTagClose(
    SymmetricTag symmetricTag,
) {
    final symmetricTagClose = DynamicLibrary.open('wasi_ephemeral_crypto_symmetric').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle symmetricTag,
        ),            CryptoErrno Function(

                SymmetricTag symmetricTag,
            )>('symmetric_tag_close');    final res = symmetricTagClose(
        symmetricTag,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(());
}



//
// This file was automatically generated by witx-codegen - Do not edit manually.
//

// ignore_for_file: non_constant_identifier_names

import 'dart:convert' show utf8;
import 'dart:ffi';
import 'dart:typed_data';

import 'package:ffi/ffi.dart' show malloc;

// #[derive(Debug, Copy, Clone, Eq, PartialEq)]
// pub enum Error {
//     WasiError(i32),
// }
// impl std::error::Error for Error {}
// impl std::fmt::Display for Error {
//     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
//         match self {
//             Error::WasiError(e) => write!(f, "Wasi error {}", e),
//         }
//     }
// }

class WasiError {
    final int code;
    const WasiError(this.code);

    @override
    String toString() {
        return 'WasiError{code: $code}';
    }
}

sealed class Result<O, E> {}

class Ok<O> implements Result<O, Never> {
    final O ok;
    const Ok(this.ok);
}

class Err<E> implements Result<Never, E> {
    final E err;
    const Err(this.err);
}

typedef i8 = Int8;
typedef i16 = Int16;
typedef i32 = Int32;
typedef i64 = Int64;
typedef u8 = Uint8;
typedef u16 = Uint16;
typedef u32 = Uint32;
typedef u64 = Uint64;
typedef usize = UintPtr;

typedef WasiHandle = i32;
typedef Char8 = u8;
typedef Char32 = u32;
typedef WasiPtr<T extends NativeType> = Pointer<T>;
typedef WasiMutPtr<T extends NativeType> = Pointer<T>;
typedef WasiStringBytesPtr = WasiPtr<Char8>;

// typedef WasiSlice<T extends NativeType> = Array<T>;

final class WasiSlice extends Struct {
    external WasiPtr<NativeType> ptr;
    @usize()
    external int len;

    List<T> asSlice<T>({
        required int itemSize,
        required T Function(WasiPtr<NativeType> ptr) fromPointer,
    }) {
        final result = <T>[];
        for (var i = ptr.address; i < len * itemSize; i += itemSize) {
            result.add(fromPointer(Pointer.fromAddress(i)));
        }
        return result;
    }

    static WasiSlice fromSlice<T>(
        List<T> slice, {
        required int itemSize,
        required void Function(T value, WasiPtr<NativeType> ptr) populatePointer,
    }) {
        final result = malloc<WasiSlice>();
        result.ref.ptr = malloc.allocate(slice.length * itemSize);
        result.ref.len = slice.length;
        final address = result.ref.ptr.address;
        for (var i = 0; i < slice.length; i++) {
            populatePointer(
                slice[i],
                Pointer.fromAddress(address + i * itemSize),
            );
        }
        return result.ref;
    }
}

final class WasiString extends Struct {
    external WasiStringBytesPtr ptr;
    @usize()
    external int len;

    static WasiString fromUtf8Slice(List<int> slice) {
        final stringPointer = malloc<WasiString>();
        final Pointer<Uint8> result = malloc<Uint8>(slice.length);
        result.asTypedList(slice.length).setAll(0, slice);

        return stringPointer.ref
            ..ptr = result
            ..len = slice.length;
    }

    static WasiString fromString(String v) {
        return fromUtf8Slice(utf8.encode(v));
    }

    Uint8List toUtf8Slice() {
        return ptr.asTypedList(len);
    }

    @override
    String toString() {
        final c = ptr.asTypedList(len);
        return utf8.decode(c);
    }
}

// ---------------------- Module: [test_module] ----------------------

/// An enumeration
typedef TestErrno = int /* u16 */;

class TEST_ERRNO {
    static const TestErrno SUCCESS = 0;
    static const TestErrno GUEST_ERROR = 1;
    static const TestErrno SOME_OTHER_ERROR = 2;
}

/// A boolean alias
typedef TestBool = bool;

/// A u32 alias
typedef TestMediumInt = int /* u32 */;

class TEST_MEDIUM_INT {
    static const TestMediumInt ZERO = 0;
    static const TestMediumInt ONE = 1;
    static const TestMediumInt TWO = 2;
    static const TestMediumInt THREE = 3;
}

/// A u64 alias
typedef TestBigInt = int /* u64 */;

class TEST_BIG_INT {
    static const TestBigInt ZERO = 0x0;
    static const TestBigInt A_HUNDRED = 0x64;
    static const TestBigInt A_BIG_VALUE = 0xff00000000000000;
    static const TestBigInt A_BIGGER_VALUE = 0xffffffffffffffff;
}

/// Flags
typedef TestBigFlags = int /* u8 */;

class TEST_BIG_FLAGS {
    static const TestBigFlags A = 0x1;
    static const TestBigFlags B = 0x2;
    static const TestBigFlags C = 0x4;
    static const TestBigFlags D = 0x8;
}


/// A structure
final class TestStruct extends Struct {
    @Bool() external bool aBoolean;
    @u8() external int /* u8 */ aByte;
    @u16() external int __pad16_0;
    external WasiString aString;
}


/// A tuple
final class TestTuple extends Struct { // -- Tuple
    @Bool() external TestBool v0;
    @u8() external int __pad8_0;
    @u16() external int __pad16_0;
    @u32() external TestMediumInt v1;
    @u64() external TestBigInt v2;
}


/// A string
typedef TestString = WasiString;

/// An output buffer
typedef TestOutputBuffer = WasiSlice /* Mut <int /* u16 */> */;

/// An input buffer
typedef TestInputBuffer = WasiSlice /* <int /* u16 */> */;

/// A tagged union
final class TestTaggedUnionMember extends Union {
    @u8() external int /* u8 */ firstChoice; // if tag=0
    external WasiString secondChoice; // if tag=1
    @Float() external double /* f32 */ thirdChoice; // if tag=2
    // emptyChoice with no associated value if tag=3
}

final class TestTaggedUnion extends Struct {
    @u16() external int /* u16 */ tag;
    @u16() external int __pad16_0;
    @u64() external int __pad64_0;
    external Pointer<TestTaggedUnionMember> member;
    static TestTaggedUnion fromTag(int /* u16 */ tag) {
        final tu = malloc<TestTaggedUnion>();
        tu.ref.tag = tag;
        return tu.ref;
    }


    // --- firstChoice: int /* u8 */ if tag=0

    TestTaggedUnion newFirstChoice(int /* u8 */ val) {
        final tu = fromTag(0);
        tu.member.ref.firstChoice = val;
        return tu;
    }

    int /* u8 */ intoFirstChoice() {
        assert(tag == 0);
        return member.ref.firstChoice;
    }

    void setFirstChoice(int /* u8 */ val) {
        assert(tag == 0);
        member.ref.firstChoice = val;
    }

    bool isFirstChoice() {
        return tag == 0;
    }


    // --- secondChoice: WasiString if tag=1

    TestTaggedUnion newSecondChoice(WasiString val) {
        final tu = fromTag(1);
        tu.member.ref.secondChoice = val;
        return tu;
    }

    WasiString intoSecondChoice() {
        assert(tag == 1);
        return member.ref.secondChoice;
    }

    void setSecondChoice(WasiString val) {
        assert(tag == 1);
        member.ref.secondChoice = val;
    }

    bool isSecondChoice() {
        return tag == 1;
    }


    // --- thirdChoice: double /* f32 */ if tag=2

    TestTaggedUnion newThirdChoice(double /* f32 */ val) {
        final tu = fromTag(2);
        tu.member.ref.thirdChoice = val;
        return tu;
    }

    double /* f32 */ intoThirdChoice() {
        assert(tag == 2);
        return member.ref.thirdChoice;
    }

    void setThirdChoice(double /* f32 */ val) {
        assert(tag == 2);
        member.ref.thirdChoice = val;
    }

    bool isThirdChoice() {
        return tag == 2;
    }


    // --- emptyChoice: (no associated content) if tag=3

    TestTaggedUnion newEmptyChoice() {
        return fromTag(3);
    }

    bool isEmptyChoice() {
        return tag == 3;
    }

}


/// This function returns multiple values
Result<(TestMediumInt, TestBigInt), Error> aFunctionThatReturnsMultipleValues(
    int /* u64 */ someParameter,
    WasiPtr<u8> someOtherParameterPtr,
    int /* usize */ someOtherParameterLen,
) {
    final aFunctionThatReturnsMultipleValues = DynamicLibrary.open('test_module').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            u64 someParameter,
            int /* Char8 */ someOtherParameterPtr,
            usize someOtherParameterLen,
            TestMediumInt result0Ptr,
            TestBigInt result1Ptr,
        ),            TestErrno Function(

                int /* u64 */ someParameter,
                WasiPtr<u8> someOtherParameterPtr,
                int /* usize */ someOtherParameterLen,
                WasiPtr<u32> /* Mut */ result0Ptr,
                WasiPtr<u64> /* Mut */ result1Ptr,
            )>('a_function_that_returns_multiple_values');    final result0Ptr = malloc<u32>();
    final result1Ptr = malloc<u64>();
    final res = aFunctionThatReturnsMultipleValues(
        someParameter,
        someOtherParameterPtr,
        someOtherParameterLen,
        result0Ptr,
        result1Ptr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok((result0Ptr.ref, result1Ptr.ref));
}

/// This function returns an actual tuple (expanded into multiple values)
Result<(TestBool, TestMediumInt, TestBigInt), Error> aFunctionThatReturnsAnActualTuple(
    int /* u64 */ someParameter,
) {
    final aFunctionThatReturnsAnActualTuple = DynamicLibrary.open('test_module').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            u64 someParameter,
            TestBool result0Ptr,
            TestMediumInt result1Ptr,
            TestBigInt result2Ptr,
        ),            TestErrno Function(

                int /* u64 */ someParameter,
                WasiPtr<Bool> /* Mut */ result0Ptr,
                WasiPtr<u32> /* Mut */ result1Ptr,
                WasiPtr<u64> /* Mut */ result2Ptr,
            )>('a_function_that_returns_an_actual_tuple');    final result0Ptr = malloc<Bool>();
    final result1Ptr = malloc<u32>();
    final result2Ptr = malloc<u64>();
    final res = aFunctionThatReturnsAnActualTuple(
        someParameter,
        result0Ptr,
        result1Ptr,
        result2Ptr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok((result0Ptr.ref, result1Ptr.ref, result2Ptr.ref));
}

/// This function returns nothing
Result<(), Error> aFunctionThatReturnsNothing(
    int /* u64 */ someParameter,
) {
    final aFunctionThatReturnsNothing = DynamicLibrary.open('test_module').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            u64 someParameter,
        ),            TestErrno Function(

                int /* u64 */ someParameter,
            )>('a_function_that_returns_nothing');    final res = aFunctionThatReturnsNothing(
        someParameter,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(());
}

/// This function gets a string
Result<TestBool, Error> aFunctionThatGetsAString(
    WasiPtr<u8> strPtr,
    int /* usize */ strLen,
) {
    final aFunctionThatGetsAString = DynamicLibrary.open('test_module').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            int /* Char8 */ strPtr,
            usize strLen,
            TestBool resultPtr,
        ),            TestErrno Function(

                WasiPtr<u8> strPtr,
                int /* usize */ strLen,
                WasiPtr<Bool> /* Mut */ resultPtr,
            )>('a_function_that_gets_a_string');    final resultPtr = malloc<Bool>();
    final res = aFunctionThatGetsAString(
        strPtr,
        strLen,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// This function return a tagged union
Result<TestTaggedUnion, Error> aFunctionThatReturnsATaggedUnion(
    WasiPtr<u8> strPtr,
    int /* usize */ strLen,
) {
    final aFunctionThatReturnsATaggedUnion = DynamicLibrary.open('test_module').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            int /* Char8 */ strPtr,
            usize strLen,
            TestTaggedUnion resultPtr,
        ),            TestErrno Function(

                WasiPtr<u8> strPtr,
                int /* usize */ strLen,
                WasiPtr<unimplemented!()> /* Mut */ resultPtr,
            )>('a_function_that_returns_a_tagged_union');    final resultPtr = malloc<unimplemented!()>();
    final res = aFunctionThatReturnsATaggedUnion(
        strPtr,
        strLen,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// This function gets and returns a string
Result<TestString, Error> aFunctionThatGetsAndReturnsAString(
    WasiPtr<u8> strPtr,
    int /* usize */ strLen,
) {
    final aFunctionThatGetsAndReturnsAString = DynamicLibrary.open('test_module').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            int /* Char8 */ strPtr,
            usize strLen,
            TestString resultPtr,
        ),            TestErrno Function(

                WasiPtr<u8> strPtr,
                int /* usize */ strLen,
                WasiPtr<WasiString> /* Mut */ resultPtr,
            )>('a_function_that_gets_and_returns_a_string');    final resultPtr = malloc<WasiString>();
    final res = aFunctionThatGetsAndReturnsAString(
        strPtr,
        strLen,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}



//
// This file was automatically generated by witx-codegen - Do not edit manually.
//

// ignore_for_file: non_constant_identifier_names

import 'dart:convert' show utf8;
import 'dart:ffi';
import 'dart:typed_data';

import 'package:ffi/ffi.dart' show malloc;

// #[derive(Debug, Copy, Clone, Eq, PartialEq)]
// pub enum Error {
//     WasiError(i32),
// }
// impl std::error::Error for Error {}
// impl std::fmt::Display for Error {
//     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
//         match self {
//             Error::WasiError(e) => write!(f, "Wasi error {}", e),
//         }
//     }
// }

class WasiError {
    final int code;
    const WasiError(this.code);

    @override
    String toString() {
        return 'WasiError{code: $code}';
    }
}

sealed class Result<O, E> {}

class Ok<O> implements Result<O, Never> {
    final O ok;
    const Ok(this.ok);
}

class Err<E> implements Result<Never, E> {
    final E err;
    const Err(this.err);
}

typedef i8 = Int8;
typedef i16 = Int16;
typedef i32 = Int32;
typedef i64 = Int64;
typedef u8 = Uint8;
typedef u16 = Uint16;
typedef u32 = Uint32;
typedef u64 = Uint64;
typedef usize = UintPtr;

typedef WasiHandle = i32;
typedef Char8 = u8;
typedef Char32 = u32;
typedef WasiPtr<T extends NativeType> = Pointer<T>;
typedef WasiMutPtr<T extends NativeType> = Pointer<T>;
typedef WasiStringBytesPtr = WasiPtr<Char8>;

// typedef WasiSlice<T extends NativeType> = Array<T>;

final class WasiSlice extends Struct {
    external WasiPtr<NativeType> ptr;
    @usize()
    external int len;

    List<T> asSlice<T>({
        required int itemSize,
        required T Function(WasiPtr<NativeType> ptr) fromPointer,
    }) {
        final result = <T>[];
        for (var i = ptr.address; i < len * itemSize; i += itemSize) {
            result.add(fromPointer(Pointer.fromAddress(i)));
        }
        return result;
    }

    static WasiSlice fromSlice<T>(
        List<T> slice, {
        required int itemSize,
        required void Function(T value, WasiPtr<NativeType> ptr) populatePointer,
    }) {
        final result = malloc<WasiSlice>();
        result.ref.ptr = malloc.allocate(slice.length * itemSize);
        result.ref.len = slice.length;
        final address = result.ref.ptr.address;
        for (var i = 0; i < slice.length; i++) {
            populatePointer(
                slice[i],
                Pointer.fromAddress(address + i * itemSize),
            );
        }
        return result.ref;
    }
}

final class WasiString extends Struct {
    external WasiStringBytesPtr ptr;
    @usize()
    external int len;

    static WasiString fromUtf8Slice(List<int> slice) {
        final stringPointer = malloc<WasiString>();
        final Pointer<Uint8> result = malloc<Uint8>(slice.length);
        result.asTypedList(slice.length).setAll(0, slice);

        return stringPointer.ref
            ..ptr = result
            ..len = slice.length;
    }

    static WasiString fromString(String v) {
        return fromUtf8Slice(utf8.encode(v));
    }

    Uint8List toUtf8Slice() {
        return ptr.asTypedList(len);
    }

    @override
    String toString() {
        final c = ptr.asTypedList(len);
        return utf8.decode(c);
    }
}

// ---------------------- Module: [wasi_ephemeral_crypto_common] ----------------------

/// Error codes.
typedef CryptoErrno = int /* u16 */;

class CRYPTO_ERRNO {
    static const CryptoErrno SUCCESS = 0;
    static const CryptoErrno GUEST_ERROR = 1;
    static const CryptoErrno NOT_IMPLEMENTED = 2;
    static const CryptoErrno UNSUPPORTED_FEATURE = 3;
    static const CryptoErrno PROHIBITED_OPERATION = 4;
    static const CryptoErrno UNSUPPORTED_ENCODING = 5;
    static const CryptoErrno UNSUPPORTED_ALGORITHM = 6;
    static const CryptoErrno UNSUPPORTED_OPTION = 7;
    static const CryptoErrno INVALID_KEY = 8;
    static const CryptoErrno INVALID_LENGTH = 9;
    static const CryptoErrno VERIFICATION_FAILED = 10;
    static const CryptoErrno RNG_ERROR = 11;
    static const CryptoErrno ALGORITHM_FAILURE = 12;
    static const CryptoErrno INVALID_SIGNATURE = 13;
    static const CryptoErrno CLOSED = 14;
    static const CryptoErrno INVALID_HANDLE = 15;
    static const CryptoErrno OVERFLOW = 16;
    static const CryptoErrno INTERNAL_ERROR = 17;
    static const CryptoErrno TOO_MANY_HANDLES = 18;
    static const CryptoErrno KEY_NOT_SUPPORTED = 19;
    static const CryptoErrno KEY_REQUIRED = 20;
    static const CryptoErrno INVALID_TAG = 21;
    static const CryptoErrno INVALID_OPERATION = 22;
    static const CryptoErrno NONCE_REQUIRED = 23;
    static const CryptoErrno INVALID_NONCE = 24;
    static const CryptoErrno OPTION_NOT_SET = 25;
    static const CryptoErrno NOT_FOUND = 26;
    static const CryptoErrno PARAMETERS_MISSING = 27;
    static const CryptoErrno IN_PROGRESS = 28;
    static const CryptoErrno INCOMPATIBLE_KEYS = 29;
    static const CryptoErrno EXPIRED = 30;
}

/// Encoding to use for importing or exporting a key pair.
typedef KeypairEncoding = int /* u16 */;

class KEYPAIR_ENCODING {
    static const KeypairEncoding RAW = 0;
    static const KeypairEncoding PKCS_8 = 1;
    static const KeypairEncoding PEM = 2;
    static const KeypairEncoding LOCAL = 3;
}

/// Encoding to use for importing or exporting a public key.
typedef PublickeyEncoding = int /* u16 */;

class PUBLICKEY_ENCODING {
    static const PublickeyEncoding RAW = 0;
    static const PublickeyEncoding PKCS_8 = 1;
    static const PublickeyEncoding PEM = 2;
    static const PublickeyEncoding SEC = 3;
    static const PublickeyEncoding COMPRESSED_SEC = 4;
    static const PublickeyEncoding LOCAL = 5;
}

/// Encoding to use for importing or exporting a secret key.
typedef SecretkeyEncoding = int /* u16 */;

class SECRETKEY_ENCODING {
    static const SecretkeyEncoding RAW = 0;
    static const SecretkeyEncoding PKCS_8 = 1;
    static const SecretkeyEncoding PEM = 2;
    static const SecretkeyEncoding SEC = 3;
    static const SecretkeyEncoding COMPRESSED_SEC = 4;
    static const SecretkeyEncoding LOCAL = 5;
}

/// Encoding to use for importing or exporting a signature.
typedef SignatureEncoding = int /* u16 */;

class SIGNATURE_ENCODING {
    static const SignatureEncoding RAW = 0;
    static const SignatureEncoding DER = 1;
}

/// An algorithm category.
typedef AlgorithmType = int /* u16 */;

class ALGORITHM_TYPE {
    static const AlgorithmType SIGNATURES = 0;
    static const AlgorithmType SYMMETRIC = 1;
    static const AlgorithmType KEY_EXCHANGE = 2;
}

/// Version of a managed key.
/// 
/// A version can be an arbitrary `u64` integer, with the expection of some reserved values.
typedef Version = int /* u64 */;

class VERSION {
    static const Version UNSPECIFIED = 0xff00000000000000;
    static const Version LATEST = 0xff00000000000001;
    static const Version ALL = 0xff00000000000002;
}

/// Size of a value.
typedef Size = int /* usize */;

/// A UNIX timestamp, in seconds since 01/01/1970.
typedef Timestamp = int /* u64 */;

/// A 64-bit value
typedef U64 = int /* u64 */;

/// Handle for functions returning output whose size may be large or not known in advance.
/// 
/// An `array_output` object contains a host-allocated byte array.
/// 
/// A guest can get the size of that array after a function returns in order to then allocate a buffer of the correct size.
/// In addition, the content of such an object can be consumed by a guest in a streaming fashion.
/// 
/// An `array_output` handle is automatically closed after its full content has been consumed.
typedef ArrayOutput = WasiHandle;

/// A set of options.
/// 
/// This type is used to set non-default parameters.
/// 
/// The exact set of allowed options depends on the algorithm being used.
typedef Options = WasiHandle;

/// A handle to the optional secrets management facilities offered by a host.
/// 
/// This is used to generate, retrieve and invalidate managed keys.
typedef SecretsManager = WasiHandle;

/// A key pair.
typedef Keypair = WasiHandle;

/// A state to absorb data to be signed.
/// 
/// After a signature has been computed or verified, the state remains valid for further operations.
/// 
/// A subsequent signature would sign all the data accumulated since the creation of the state object.
typedef SignatureState = WasiHandle;

/// A signature.
typedef Signature = WasiHandle;

/// A public key, for key exchange and signature verification.
typedef Publickey = WasiHandle;

/// A secret key, for key exchange mechanisms.
typedef Secretkey = WasiHandle;

/// A state to absorb signed data to be verified.
typedef SignatureVerificationState = WasiHandle;

/// A state to perform symmetric operations.
/// 
/// The state is not reset nor invalidated after an option has been performed.
/// Incremental updates and sessions are thus supported.
typedef SymmetricState = WasiHandle;

/// A symmetric key.
/// 
/// The key can be imported from raw bytes, or can be a reference to a managed key.
/// 
/// If it was imported, the host will wipe it from memory as soon as the handle is closed.
typedef SymmetricKey = WasiHandle;

/// An authentication tag.
/// 
/// This is an object returned by functions computing authentication tags.
/// 
/// A tag can be compared against another tag (directly supplied as raw bytes) in constant time with the `symmetric_tag_verify()` function.
/// 
/// This object type can't be directly created from raw bytes. They are only returned by functions computing MACs.
/// 
/// The host is reponsible for securely wiping them from memory on close.
typedef SymmetricTag = WasiHandle;

/// Options index, only required by the Interface Types translation layer.
typedef OptOptionsU = int /* u8 */;

class OPT_OPTIONS_U {
    static const OptOptionsU SOME = 0;
    static const OptOptionsU NONE = 1;
}

/// An optional options set.
/// 
/// This union simulates an `Option<Options>` type to make the `options` parameter of some functions optional.
final class OptOptionsMember extends Union {
    @WasiHandle() external Options some; // if tag=0
    // none with no associated value if tag=1
}

final class OptOptions extends Struct {
    @u8() external int /* u8 */ tag;
    @u8() external int __pad8_0;
    @u16() external int __pad16_0;
    @u32() external int __pad32_0;
    external Pointer<OptOptionsMember> member;
    static OptOptions fromTag(int /* u8 */ tag) {
        final tu = malloc<OptOptions>();
        tu.ref.tag = tag;
        return tu.ref;
    }


    // --- some: Options if tag=0

    OptOptions newSome(Options val) {
        final tu = fromTag(0);
        tu.member.ref.some = val;
        return tu;
    }

    Options intoSome() {
        assert(tag == 0);
        return member.ref.some;
    }

    void setSome(Options val) {
        assert(tag == 0);
        member.ref.some = val;
    }

    bool isSome() {
        return tag == 0;
    }


    // --- none: (no associated content) if tag=1

    OptOptions newNone() {
        return fromTag(1);
    }

    bool isNone() {
        return tag == 1;
    }

}


/// Symmetric key index, only required by the Interface Types translation layer.
typedef OptSymmetricKeyU = int /* u8 */;

class OPT_SYMMETRIC_KEY_U {
    static const OptSymmetricKeyU SOME = 0;
    static const OptSymmetricKeyU NONE = 1;
}

/// An optional symmetric key.
/// 
/// This union simulates an `Option<SymmetricKey>` type to make the `symmetric_key` parameter of some functions optional.
final class OptSymmetricKeyMember extends Union {
    @WasiHandle() external SymmetricKey some; // if tag=0
    // none with no associated value if tag=1
}

final class OptSymmetricKey extends Struct {
    @u8() external int /* u8 */ tag;
    @u8() external int __pad8_0;
    @u16() external int __pad16_0;
    @u32() external int __pad32_0;
    external Pointer<OptSymmetricKeyMember> member;
    static OptSymmetricKey fromTag(int /* u8 */ tag) {
        final tu = malloc<OptSymmetricKey>();
        tu.ref.tag = tag;
        return tu.ref;
    }


    // --- some: SymmetricKey if tag=0

    OptSymmetricKey newSome(SymmetricKey val) {
        final tu = fromTag(0);
        tu.member.ref.some = val;
        return tu;
    }

    SymmetricKey intoSome() {
        assert(tag == 0);
        return member.ref.some;
    }

    void setSome(SymmetricKey val) {
        assert(tag == 0);
        member.ref.some = val;
    }

    bool isSome() {
        return tag == 0;
    }


    // --- none: (no associated content) if tag=1

    OptSymmetricKey newNone() {
        return fromTag(1);
    }

    bool isNone() {
        return tag == 1;
    }

}


/// Create a new object to set non-default options.
/// 
/// Example usage:
/// 
/// ```rust
/// let options_handle = options_open(AlgorithmType::Symmetric)?;
/// options_set(options_handle, "context", context)?;
/// options_set_u64(options_handle, "threads", 4)?;
/// let state = symmetric_state_open("BLAKE3", None, Some(options_handle))?;
/// options_close(options_handle)?;
/// ```
Result<Options, Error> optionsOpen(
    AlgorithmType algorithmType,
) {
    final optionsOpen = DynamicLibrary.open('wasi_ephemeral_crypto_common').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            int /* u16 */ /* Enum */ algorithmType,
            Options resultPtr,
        ),            CryptoErrno Function(

                AlgorithmType algorithmType,
                WasiPtr<WasiHandle> /* Mut */ resultPtr,
            )>('options_open');    final resultPtr = malloc<WasiHandle>();
    final res = optionsOpen(
        algorithmType,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// Destroy an options object.
/// 
/// Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
Result<(), Error> optionsClose(
    Options handle,
) {
    final optionsClose = DynamicLibrary.open('wasi_ephemeral_crypto_common').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle handle,
        ),            CryptoErrno Function(

                Options handle,
            )>('options_close');    final res = optionsClose(
        handle,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(());
}

/// Set or update an option.
/// 
/// This is used to set algorithm-specific parameters, but also to provide credentials for the secrets management facilities, if required.
/// 
/// This function may return `unsupported_option` if an option that doesn't exist for any implemented algorithms is specified.
Result<(), Error> optionsSet(
    Options handle,
    WasiPtr<u8> namePtr,
    int /* usize */ nameLen,
    WasiPtr<u8> value,
    Size valueLen,
) {
    final optionsSet = DynamicLibrary.open('wasi_ephemeral_crypto_common').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle handle,
            int /* Char8 */ namePtr,
            usize nameLen,
            int /* u8 */ value,
            usize valueLen,
        ),            CryptoErrno Function(

                Options handle,
                WasiPtr<u8> namePtr,
                int /* usize */ nameLen,
                WasiPtr<u8> value,
                Size valueLen,
            )>('options_set');    final res = optionsSet(
        handle,
        namePtr,
        nameLen,
        value,
        valueLen,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(());
}

/// Set or update an integer option.
/// 
/// This is used to set algorithm-specific parameters.
/// 
/// This function may return `unsupported_option` if an option that doesn't exist for any implemented algorithms is specified.
Result<(), Error> optionsSetU64(
    Options handle,
    WasiPtr<u8> namePtr,
    int /* usize */ nameLen,
    int /* u64 */ value,
) {
    final optionsSetU64 = DynamicLibrary.open('wasi_ephemeral_crypto_common').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle handle,
            int /* Char8 */ namePtr,
            usize nameLen,
            u64 value,
        ),            CryptoErrno Function(

                Options handle,
                WasiPtr<u8> namePtr,
                int /* usize */ nameLen,
                int /* u64 */ value,
            )>('options_set_u64');    final res = optionsSetU64(
        handle,
        namePtr,
        nameLen,
        value,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(());
}

/// Set or update a guest-allocated memory that the host can use or return data into.
/// 
/// This is for example used to set the scratch buffer required by memory-hard functions.
/// 
/// This function may return `unsupported_option` if an option that doesn't exist for any implemented algorithms is specified.
Result<(), Error> optionsSetGuestBuffer(
    Options handle,
    WasiPtr<u8> namePtr,
    int /* usize */ nameLen,
    WasiPtr<u8> /* Mut */ buffer,
    Size bufferLen,
) {
    final optionsSetGuestBuffer = DynamicLibrary.open('wasi_ephemeral_crypto_common').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle handle,
            int /* Char8 */ namePtr,
            usize nameLen,
            int /* u8 */ buffer,
            usize bufferLen,
        ),            CryptoErrno Function(

                Options handle,
                WasiPtr<u8> namePtr,
                int /* usize */ nameLen,
                WasiPtr<u8> /* Mut */ buffer,
                Size bufferLen,
            )>('options_set_guest_buffer');    final res = optionsSetGuestBuffer(
        handle,
        namePtr,
        nameLen,
        buffer,
        bufferLen,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(());
}

/// Return the length of an `array_output` object.
/// 
/// This allows a guest to allocate a buffer of the correct size in order to copy the output of a function returning this object type.
Result<Size, Error> arrayOutputLen(
    ArrayOutput arrayOutput,
) {
    final arrayOutputLen = DynamicLibrary.open('wasi_ephemeral_crypto_common').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle arrayOutput,
            Size resultPtr,
        ),            CryptoErrno Function(

                ArrayOutput arrayOutput,
                WasiPtr<usize> /* Mut */ resultPtr,
            )>('array_output_len');    final resultPtr = malloc<usize>();
    final res = arrayOutputLen(
        arrayOutput,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// Copy the content of an `array_output` object into an application-allocated buffer.
/// 
/// Multiple calls to that function can be made in order to consume the data in a streaming fashion, if necessary.
/// 
/// The function returns the number of bytes that were actually copied. `0` means that the end of the stream has been reached. The total size always matches the output of `array_output_len()`.
/// 
/// The handle is automatically closed after all the data has been consumed.
/// 
/// Example usage:
/// 
/// ```rust
/// let len = array_output_len(output_handle)?;
/// let mut out = vec![0u8; len];
/// array_output_pull(output_handle, &mut out)?;
/// ```
Result<Size, Error> arrayOutputPull(
    ArrayOutput arrayOutput,
    WasiPtr<u8> /* Mut */ buf,
    Size bufLen,
) {
    final arrayOutputPull = DynamicLibrary.open('wasi_ephemeral_crypto_common').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle arrayOutput,
            int /* u8 */ buf,
            usize bufLen,
            Size resultPtr,
        ),            CryptoErrno Function(

                ArrayOutput arrayOutput,
                WasiPtr<u8> /* Mut */ buf,
                Size bufLen,
                WasiPtr<usize> /* Mut */ resultPtr,
            )>('array_output_pull');    final resultPtr = malloc<usize>();
    final res = arrayOutputPull(
        arrayOutput,
        buf,
        bufLen,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// __(optional)__
/// Create a context to use a secrets manager.
/// 
/// The set of required and supported options is defined by the host.
/// 
/// The function returns the `unsupported_feature` error code if secrets management facilities are not supported by the host.
/// This is also an optional import, meaning that the function may not even exist.
Result<SecretsManager, Error> secretsManagerOpen(
    OptOptions options,
) {
    final secretsManagerOpen = DynamicLibrary.open('wasi_ephemeral_crypto_common').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            unimplemented!() options,
            SecretsManager resultPtr,
        ),            CryptoErrno Function(

                OptOptions options,
                WasiPtr<WasiHandle> /* Mut */ resultPtr,
            )>('secrets_manager_open');    final resultPtr = malloc<WasiHandle>();
    final res = secretsManagerOpen(
        options,
        resultPtr,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(resultPtr.ref);
}

/// __(optional)__
/// Destroy a secrets manager context.
/// 
/// The function returns the `unsupported_feature` error code if secrets management facilities are not supported by the host.
/// This is also an optional import, meaning that the function may not even exist.
Result<(), Error> secretsManagerClose(
    SecretsManager secretsManager,
) {
    final secretsManagerClose = DynamicLibrary.open('wasi_ephemeral_crypto_common').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle secretsManager,
        ),            CryptoErrno Function(

                SecretsManager secretsManager,
            )>('secrets_manager_close');    final res = secretsManagerClose(
        secretsManager,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(());
}

/// __(optional)__
/// Invalidate a managed key or key pair given an identifier and a version.
/// 
/// This asks the secrets manager to delete or revoke a stored key, a specific version of a key.
/// 
/// `key_version` can be set to a version number, to `version.latest` to invalidate the current version, or to `version.all` to invalidate all versions of a key.
/// 
/// The function returns `unsupported_feature` if this operation is not supported by the host, and `not_found` if the identifier and version don't match any existing key.
/// 
/// This is an optional import, meaning that the function may not even exist.
Result<(), Error> secretsManagerInvalidate(
    SecretsManager secretsManager,
    WasiPtr<u8> keyId,
    Size keyIdLen,
    Version keyVersion,
) {
    final secretsManagerInvalidate = DynamicLibrary.open('wasi_ephemeral_crypto_common').lookupFunction<
        int /* u16 */ /* Enum */ Function(

            WasiHandle secretsManager,
            int /* u8 */ keyId,
            usize keyIdLen,
            u64 keyVersion,
        ),            CryptoErrno Function(

                SecretsManager secretsManager,
                WasiPtr<u8> keyId,
                Size keyIdLen,
                Version keyVersion,
            )>('secrets_manager_invalidate');    final res = secretsManagerInvalidate(
        secretsManager,
        keyId,
        keyIdLen,
        keyVersion,
    );
    if (res != 0) {
        return Err(WasiError(res));
    }
    return Ok(());
}


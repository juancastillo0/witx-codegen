use std::io::Write;

use super::*;

impl DartGenerator {
    pub fn header<T: Write>(w: &mut PrettyWriter<T>) -> Result<(), Error> {
        w.write_lines(
            "
//
// This file was automatically generated by witx-codegen - Do not edit manually.
//",
        )?;
        w.write_lines(
            "
// ignore_for_file: non_constant_identifier_names

import 'dart:convert' show utf8;
import 'dart:ffi';
import 'dart:typed_data';

import 'package:ffi/ffi.dart' show malloc;

// #[derive(Debug, Copy, Clone, Eq, PartialEq)]
// pub enum Error {
//     WasiError(i32),
// }
// impl std::error::Error for Error {}
// impl std::fmt::Display for Error {
//     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
//         match self {
//             Error::WasiError(e) => write!(f, \"Wasi error {}\", e),
//         }
//     }
// }

class WasiError {
    final int code;
    const WasiError(this.code);

    @override
    String toString() {
        return 'WasiError{code: $code}';
    }
}

sealed class Result<O, E> {}

class Ok<O> implements Result<O, Never> {
    final O ok;
    const Ok(this.ok);
}

class Err<E> implements Result<Never, E> {
    final E err;
    const Err(this.err);
}

typedef i8 = Int8;
typedef i16 = Int16;
typedef i32 = Int32;
typedef i64 = Int64;
typedef u8 = Uint8;
typedef u16 = Uint16;
typedef u32 = Uint32;
typedef u64 = Uint64;
typedef usize = UintPtr;

typedef WasiHandle = i32;
typedef Char8 = u8;
typedef Char32 = u32;
typedef WasiPtr<T extends NativeType> = Pointer<T>;
typedef WasiMutPtr<T extends NativeType> = Pointer<T>;
typedef WasiStringBytesPtr = WasiPtr<Char8>;

// typedef WasiSlice<T extends NativeType> = Array<T>;

final class WasiSlice extends Struct {
    external WasiPtr<NativeType> ptr;
    @usize()
    external int len;

    List<T> asSlice<T>({
        required int itemSize,
        required T Function(WasiPtr<NativeType> ptr) fromPointer,
    }) {
        final result = <T>[];
        for (var i = ptr.address; i < len * itemSize; i += itemSize) {
            result.add(fromPointer(Pointer.fromAddress(i)));
        }
        return result;
    }

    static WasiSlice fromSlice<T>(
        List<T> slice, {
        required int itemSize,
        required void Function(T value, WasiPtr<NativeType> ptr) populatePointer,
    }) {
        final result = malloc<WasiSlice>();
        result.ref.ptr = malloc.allocate(slice.length * itemSize);
        result.ref.len = slice.length;
        final address = result.ref.ptr.address;
        for (var i = 0; i < slice.length; i++) {
            populatePointer(
                slice[i],
                Pointer.fromAddress(address + i * itemSize),
            );
        }
        return result.ref;
    }
}

final class WasiString extends Struct {
    external WasiStringBytesPtr ptr;
    @usize()
    external int len;

    static WasiString fromUtf8Slice(List<int> slice) {
        final stringPointer = malloc<WasiString>();
        final Pointer<Uint8> result = malloc<Uint8>(slice.length);
        result.asTypedList(slice.length).setAll(0, slice);

        return stringPointer.ref
            ..ptr = result
            ..len = slice.length;
    }

    static WasiString fromString(String v) {
        return fromUtf8Slice(utf8.encode(v));
    }

    Uint8List toUtf8Slice() {
        return ptr.asTypedList(len);
    }

    @override
    String toString() {
        final c = ptr.asTypedList(len);
        return utf8.decode(c);
    }
}
",
        )?;
        w.eob()?;
        Ok(())
    }
}
